package pegwings

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"

	"github.com/pegwings/pegwings-go/pkg/builders"
	"github.com/pegwings/pegwings-go/pkg/pegwingerrs"
	"github.com/pegwings/pegwings-go/pkg/schema"
	"github.com/pegwings/pegwings-go/pkg/streams"
	"github.com/pegwings/pegwings-go/pkg/tools"
)

// ImageURLDetail is the detail of the image at the URL.
//
// string
type ImageURLDetail string

// Role is the role of the chat completion message.
//
// string
type Role string

const (
	// RoleSystem is the system chat message role.
	RoleSystem Role = "system"
	// RoleUser is the user chat message role.
	RoleUser Role = "user"
	// RoleAssistant is the assistant chat message role.
	RoleAssistant Role = "assistant"
	// RoleFunction is the function chat message role.
	RoleFunction Role = "function"
	// RoleTool is the tool chat message role.
	RoleTool Role = "tool"
)

type (
	// ChatMessagePartType is the chat message part type.
	//
	// string
	ChatMessagePartType string
	// PromptAnnotation represents the prompt annotation.
	PromptAnnotation struct {
		PromptIndex int `json:"prompt_index,omitempty"`
	}
	// ChatMessageImageURL represents the chat message image url.
	ChatMessageImageURL struct {
		// URL is the url of the image.
		URL string `json:"url,omitempty"`
		// Detail is the detail of the image url.
		Detail ImageURLDetail `json:"detail,omitempty"`
	}
	// ChatMessagePart represents the chat message part of a chat completion
	// message.
	ChatMessagePart struct {
		// Text is the text of the chat message part.
		Text string `json:"text,omitempty"`
		// Type is the type of the chat message part.
		Type ChatMessagePartType `json:"type,omitempty"`
		// ImageURL is the image url of the chat message part.
		ImageURL *ChatMessageImageURL `json:"image_url,omitempty"`
	}
	// ChatCompletionMessage represents the chat completion message.
	ChatCompletionMessage struct {
		// Name is the name of the chat completion message.
		Name string `json:"name"`
		// Role is the role of the chat completion message.
		Role Role `json:"role"`
		// Content is the content of the chat completion message.
		Content string `json:"content"`
		// MultiContent is the multi content of the chat completion
		// message.
		MultiContent []ChatMessagePart `json:"-"`
		// FunctionCall setting for Role=assistant prompts this may be
		// set to the function call generated by the model.
		FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
		// ToolCalls setting for Role=assistant prompts this may be set
		// to the tool calls generated by the model, such as function
		// calls.
		ToolCalls []tools.ToolCall `json:"tool_calls,omitempty"`
		// ToolCallID is setting for Role=tool prompts this should be
		// set to the ID given in the assistant's prior request to call
		// a tool.
		ToolCallID string `json:"tool_call_id,omitempty"`
	}
	// ChatCompletionResponseFormat is the chat completion response format.
	ChatCompletionResponseFormat struct {
		// Type is the type of the chat completion response format.
		Type Format `json:"type,omitempty"`
		// JSONSchema is the json schema of the chat completion response
		// format.
		JSONSchema *ChatCompletionResponseFormatJSONSchema `json:"json_schema,omitempty"`
	}
	// ChatCompletionResponseFormatJSONSchema is the chat completion
	// response format json schema.
	ChatCompletionResponseFormatJSONSchema struct {
		// Name is the name of the chat completion response format json
		// schema.
		//
		// it is used to further identify the schema in the response.
		Name string `json:"name"`
		// Description is the description of the chat completion
		// response format json schema.
		Description string `json:"description,omitempty"`
		// Schema is the schema of the chat completion response format
		// json schema.
		Schema schema.Schema `json:"schema"`
		// Strict determines whether to enforce the schema upon the
		// generated content.
		Strict bool `json:"strict"`
	}
	// LogProbs is the top-level structure containing the log probability information.
	LogProbs struct {
		// Content is a list of message content tokens with log
		// probability information.
		Content []struct {
			LogProb `json:"logprob"`
			// TopLogProbs is a list of the most likely tokens and
			// their log probability, at this token position. In
			// rare cases, there may be fewer than the number of
			// requested top_logprobs returned.
			TopLogProbs []LogProb `json:"top_logprobs"`
		} `json:"content"`
	}
	// LogProb represents the top log probs.
	LogProb struct {
		// Token is the token that this log probability is for.
		Token string `json:"token"`
		// LogProb is the log prob of the top log probs.
		LogProb float64 `json:"logprob"`
		// Bytes is the bytes of the top log probs.
		Bytes []byte `json:"bytes,omitempty"`
	}
	// ChatCompletionChoice represents the chat completion choice.
	ChatCompletionChoice struct {
		Index int `json:"index"` // Index is the index of the choice.
		// Message is the chat completion message of the choice.
		Message ChatCompletionMessage `json:"message"`
		// FinishReason is the finish reason of the choice.
		FinishReason FinishReason `json:"finish_reason"`
		// LogProbs is the log probs of the choice.
		//
		// This is basically the probability of the model choosing the
		// token.
		LogProbs *LogProbs `json:"logprobs,omitempty"`
	}
	// ChatCompletionStreamChoiceDelta represents a response structure for
	// chat completion API.
	ChatCompletionStreamChoiceDelta struct {
		// Content is the content of the response.
		Content string `json:"content,omitempty"`
		// Role is the role of the creator of the completion.
		Role string `json:"role,omitempty"`
		// FunctionCall is the function call of the response.
		FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
		// ToolCalls are the tool calls of the response.
		ToolCalls []tools.ToolCall `json:"tool_calls,omitempty"`
	}
	// ChatCompletionStreamChoice represents a response structure for chat
	// completion API.
	ChatCompletionStreamChoice struct {
		// Index is the index of the choice.
		Index int `json:"index"`
		// Delta is the delta of the choice.
		Delta ChatCompletionStreamChoiceDelta `json:"delta"`
		// FinishReason is the finish reason of the choice.
		FinishReason FinishReason `json:"finish_reason"`
	}
	// StreamOptions represents the stream options.
	StreamOptions struct {
		// IncludeUsage is the include usage option of the stream
		// options.
		//
		// If set, an additional chunk will be streamed before the data:
		// [DONE] message.
		// The usage field on this chunk shows the token usage
		// statistics for the entire request, and the choices field will
		// always be an empty array.
		//
		// All other chunks will also include a usage field, but with a
		// null value.
		IncludeUsage bool `json:"include_usage,omitempty"`
	}
	// ChatCompletionStream is a stream of ChatCompletionStreamResponse.
	ChatCompletionStream struct {
		*streams.StreamReader[*ChatCompletionStreamResponse]
	}
)

type (
	// FinishReason is the finish reason.
	//
	// string
	FinishReason string
)

const (
	// ReasonStop is the stop finish reason for a chat completion.
	ReasonStop FinishReason = "stop"
	// ReasonLength is the length finish reason for a chat completion.
	ReasonLength FinishReason = "length"
	// ReasonFunctionCall is the function call finish reason for a chat
	// completion.
	ReasonFunctionCall FinishReason = "function_call"
	// ReasonToolCalls is the tool calls finish reason for a chat
	// completion.
	ReasonToolCalls FinishReason = "tool_calls"
	// ReasonContentFilter is the content filter finish reason for a chat
	// completion.
	ReasonContentFilter FinishReason = "content_filter"
	// ReasonNull is the null finish reason for a chat completion.
	ReasonNull FinishReason = "null"
)

const (

	// ImageURLDetailHigh is the high image url detail.
	ImageURLDetailHigh ImageURLDetail = "high"
	// ImageURLDetailLow is the low image url detail.
	ImageURLDetailLow ImageURLDetail = "low"
	// ImageURLDetailAuto is the auto image url detail.
	ImageURLDetailAuto ImageURLDetail = "auto"

	// ChatMessagePartTypeText is the text chat message part type.
	ChatMessagePartTypeText ChatMessagePartType = "text"
	// ChatMessagePartTypeImageURL is the image url chat message part type.
	ChatMessagePartTypeImageURL ChatMessagePartType = "image_url"
)

// MarshalJSON method implements the json.Marshaler interface.
//
// It exists to allow for the use of the multi-part content field.
func (m ChatCompletionMessage) MarshalJSON() ([]byte, error) {
	if m.Content != "" && m.MultiContent != nil {
		return nil, &pegwingerrs.ErrContentFieldsMisused{}
	}
	if len(m.MultiContent) > 0 {
		msg := struct {
			Name         string              `json:"name,omitempty"`
			Role         Role                `json:"role"`
			Content      string              `json:"-"`
			MultiContent []ChatMessagePart   `json:"content,omitempty"`
			FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
			ToolCalls    []tools.ToolCall    `json:"tool_calls,omitempty"`
			ToolCallID   string              `json:"tool_call_id,omitempty"`
		}(m)
		return json.Marshal(msg)
	}
	msg := struct {
		Name         string              `json:"name,omitempty"`
		Role         Role                `json:"role"`
		Content      string              `json:"content"`
		MultiContent []ChatMessagePart   `json:"-"`
		FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
		ToolCalls    []tools.ToolCall    `json:"tool_calls,omitempty"`
		ToolCallID   string              `json:"tool_call_id,omitempty"`
	}(m)
	return json.Marshal(msg)
}

// UnmarshalJSON method implements the json.Unmarshaler interface.
//
// It exists to allow for the use of the multi-part content field.
func (m *ChatCompletionMessage) UnmarshalJSON(bs []byte) (err error) {
	msg := struct {
		Name         string `json:"name,omitempty"`
		Role         Role   `json:"role"`
		Content      string `json:"content"`
		MultiContent []ChatMessagePart
		FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
		ToolCalls    []tools.ToolCall    `json:"tool_calls,omitempty"`
		ToolCallID   string              `json:"tool_call_id,omitempty"`
	}{}
	err = json.Unmarshal(bs, &msg)
	if err == nil {
		*m = ChatCompletionMessage(msg)
		return nil
	}
	multiMsg := struct {
		Name         string `json:"name,omitempty"`
		Role         Role   `json:"role"`
		Content      string
		MultiContent []ChatMessagePart   `json:"content"`
		FunctionCall *tools.FunctionCall `json:"function_call,omitempty"`
		ToolCalls    []tools.ToolCall    `json:"tool_calls,omitempty"`
		ToolCallID   string              `json:"tool_call_id,omitempty"`
	}{}
	err = json.Unmarshal(bs, &multiMsg)
	if err != nil {
		return err
	}
	*m = ChatCompletionMessage(multiMsg)
	return nil
}

// MarshalJSON implements the json.Marshaler interface.
func (r FinishReason) MarshalJSON() ([]byte, error) {
	if r == ReasonNull || r == "" {
		return []byte("null"), nil
	}
	return []byte(
		`"` + string(r) + `"`,
	), nil // best effort to not break future API changes
}

// SetHeader sets the header of the response.
func (r *ChatCompletionResponse) SetHeader(h http.Header) { r.header = h }

type (
	// Format is the format of a response.
	// string
	Format string
	// Usage Represents the total token usage per request to pegwings.
	Usage struct {
		PromptTokens     int `json:"prompt_tokens"`
		CompletionTokens int `json:"completion_tokens"`
		TotalTokens      int `json:"total_tokens"`
	}
	endpoint       string
	fullURLOptions struct{ model string }
	fullURLOption  func(*fullURLOptions)
	response       interface{ SetHeader(http.Header) }
)

const (
	// FormatText is the text format. It is the default format of a
	// response.
	FormatText Format = "text"
	// FormatJSON is the JSON format. There is no support for streaming with
	// JSON format selected.
	FormatJSON Format = "json"
	// FormatSRT is the SRT format. This is a text format that is only
	// supported for the transcription API.
	// SRT format selected.
	FormatSRT Format = "srt"
	// FormatVTT is the VTT format. This is a text format that is only
	// supported for the transcription API.
	FormatVTT Format = "vtt"
	// FormatVerboseJSON is the verbose JSON format. This is a JSON format
	// that is only supported for the transcription API.
	FormatVerboseJSON Format = "verbose_json"
	// FormatJSONObject is the json object chat
	// completion response format type.
	FormatJSONObject Format = "json_object"
	// FormatJSONSchema is the json schema chat
	// completion response format type.
	FormatJSONSchema Format = "json_schema"

	// groqAPIURLv1 is the base URL for the Groq API.
	groqAPIURLv1 = "https://api.pegwings.com/v1"
)

type (
	// Words is the words of the audio response.
	Words []struct {
		// Word is the textual representation of a word in the audio
		// response.
		Word string `json:"word"`
		// Start is the start of the words in seconds.
		Start float64 `json:"start"`
		// End is the end of the words in seconds.
		End float64 `json:"end"`
	}
	// Segments is the segments of the response.
	Segments []struct {
		// ID is the ID of the segment.
		ID int `json:"id"`
		// Seek is the seek of the segment.
		Seek int `json:"seek"`
		// Start is the start of the segment.
		Start float64 `json:"start"`
		// End is the end of the segment.
		End float64 `json:"end"`
		// Text is the text of the segment.
		Text string `json:"text"`
		// Tokens is the tokens of the segment.
		Tokens []int `json:"tokens"`
		// Temperature is the temperature of the segment.
		Temperature float64 `json:"temperature"`
		// AvgLogprob is the avg log prob of the segment.
		AvgLogprob float64 `json:"avg_logprob"`
		// CompressionRatio is the compression ratio of the segment.
		CompressionRatio float64 `json:"compression_ratio"`
		// NoSpeechProb is the no speech prob of the segment.
		NoSpeechProb float64 `json:"no_speech_prob"`
		// Transient is the transient of the segment.
		Transient bool `json:"transient"`
	}
)

// SetHeader sets the header of the response.
func (r *AudioResponse) SetHeader(header http.Header) { r.header = header }

// SetHeader sets the header of the audio text response.
func (r *audioTextResponse) SetHeader(header http.Header) { r.header = header }

// toAudioResponse converts the audio text response to an audio response.
func (r *audioTextResponse) toAudioResponse() AudioResponse {
	return AudioResponse{Text: r.Text, header: r.header}
}

func (r AudioRequest) hasJSONResponse() bool {
	return r.Format == "" || r.Format == FormatJSON ||
		r.Format == FormatVerboseJSON
}

// AudioMultipartForm creates a form with audio file contents and the name of
// the model to use for audio processing.
func AudioMultipartForm(request AudioRequest, b builders.FormBuilder) error {
	err := createFileField(request, b)
	if err != nil {
		return err
	}
	err = b.WriteField("model", string(request.Model))
	if err != nil {
		return fmt.Errorf("writing model name: %w", err)
	}
	// Create a form field for the prompt (if provided)
	if request.Prompt != "" {
		err = b.WriteField("prompt", request.Prompt)
		if err != nil {
			return fmt.Errorf("writing prompt: %w", err)
		}
	}
	// Create a form field for the format (if provided)
	if request.Format != "" {
		err = b.WriteField("response_format", string(request.Format))
		if err != nil {
			return fmt.Errorf("writing format: %w", err)
		}
	}
	// Create a form field for the temperature (if provided)
	if request.Temperature != 0 {
		err = b.WriteField(
			"temperature",
			fmt.Sprintf("%.2f", request.Temperature),
		)
		if err != nil {
			return fmt.Errorf("writing temperature: %w", err)
		}
	}
	// Create a form field for the language (if provided)
	if request.Language != "" {
		err = b.WriteField("language", request.Language)
		if err != nil {
			return fmt.Errorf("writing language: %w", err)
		}
	}
	return b.Close()
}

func createFileField(
	request AudioRequest,
	b builders.FormBuilder,
) (err error) {
	if request.Reader != nil {
		err := b.CreateFormFileReader("file", request.Reader, request.FilePath)
		if err != nil {
			return fmt.Errorf("creating form using reader: %w", err)
		}
		return nil
	}
	f, err := os.Open(request.FilePath)
	if err != nil {
		return fmt.Errorf("opening audio file: %w", err)
	}
	defer f.Close()
	err = b.CreateFormFile("file", f)
	if err != nil {
		return fmt.Errorf("creating form file: %w", err)
	}
	return nil
}

type (
	// Moderation is a category of harmful content that can be used to
	// categorize a chat history using Llama Guard 3.
	//
	// [Llama Guard 3](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-3/)
	//
	// Llama Guard 3 provides content safety support for the following
	// languages: English, French, German, Hindi, Italian, Portuguese,
	// Spanish, and Thai.
	//
	// string
	Moderation string
)

const (
	// ModerationViolentCrimes (S1) is the violent crimes category.
	//
	// Responses that enable, encourage, or endorse the commission of
	// violent crimes, including: (1) unlawful violence toward people
	// (ex: terrorism, genocide, murder, hate-motivated violent crimes,
	// child abuse, assault, battery, kidnapping) and (2) unlawful violence
	// toward animals (ex: animal abuse)
	ModerationViolentCrimes Moderation = "violent_crimes"
	// ModerationNonviolentCrimes (S2) is the non-violent crimes category.
	ModerationNonviolentCrimes Moderation = "non_violent_crimes"
	// ModerationSexRelatedCrimes (S3) is the sex-related crimes category.
	ModerationSexRelatedCrimes Moderation = "sex_related_crimes"
	// ModerationChildSexualExploitation (S4) is the child sexual exploitation
	// category.
	//
	// Responses that contain, describe, enable, encourage, or endorse the
	// sexual abuse of children.
	ModerationChildSexualExploitation Moderation = "child_sexual_exploitation"
	// ModerationDefamation (S5) is the defamation category.
	//
	// Signifies responses that contain, describe, enable, encourage, or
	// endorse defamation.
	ModerationDefamation Moderation = "defamation"
	// ModerationSpecializedAdvice (S6) is the specialized advice category.
	//
	// Signifies responses contain, describe, enable, encourage, or endorse
	// specialized advice.
	ModerationSpecializedAdvice Moderation = "specialized_advice"
	// ModerationPrivacy (S7) is the privacy category.
	//
	// Responses contain, describe, enable, encourage, or endorse privacy.
	ModerationPrivacy Moderation = "privacy"
	// ModerationIntellectualProperty (S8) is the intellectual property
	// category. Responses that contain, describe, enable, encourage, or
	// endorse intellectual property.
	ModerationIntellectualProperty Moderation = "intellectual_property"
	// ModerationIndiscriminateWeapons (S9) is the indiscriminate weapons
	// category.
	//
	// Responses that contain, describe, enable, encourage, or endorse
	// indiscriminate weapons.
	ModerationIndiscriminateWeapons Moderation = "indiscriminate_weapons"
	// ModerationHate (S10) is the hate category.
	//
	// Responses contain, describe, enable, encourage, or endorse hate.
	ModerationHate Moderation = "hate"
	// ModerationSuicideOrSelfHarm (S11) is the suicide/self-harm category.
	//
	// Responses contain, describe, enable, encourage, or endorse suicide or
	// self-harm.
	ModerationSuicideOrSelfHarm Moderation = "suicide_and_self_harm"
	// ModerationSexualContent (S12) is the sexual content category.
	//
	// Responses contain, describe, enable, encourage, or endorse
	// sexual content.
	ModerationSexualContent Moderation = "sexual_content"
	// ModerationElections (S13) is the elections category.
	//
	// Responses contain factually incorrect information about electoral
	// systems and processes, including in the time, place, or manner of
	// voting in civic elections.
	ModerationElections Moderation = "elections"
	// ModerationCodeInterpreterAbuse (S14) is the code interpreter abuse
	// category.
	//
	// Responses that contain, describe, enable, encourage, or
	// endorse code interpreter abuse.
	ModerationCodeInterpreterAbuse Moderation = "code_interpreter_abuse"
)

var (
	sectionMap = map[string]Moderation{
		"S1":  ModerationViolentCrimes,
		"S2":  ModerationNonviolentCrimes,
		"S3":  ModerationSexRelatedCrimes,
		"S4":  ModerationChildSexualExploitation,
		"S5":  ModerationDefamation,
		"S6":  ModerationSpecializedAdvice,
		"S7":  ModerationPrivacy,
		"S8":  ModerationIntellectualProperty,
		"S9":  ModerationIndiscriminateWeapons,
		"S10": ModerationHate,
		"S11": ModerationSuicideOrSelfHarm,
		"S12": ModerationSexualContent,
		"S13": ModerationElections,
		"S14": ModerationCodeInterpreterAbuse,
	}
)

// # Embeddings

// EmbeddingsFormat is the format for the embedding response.
// string
type EmbeddingsFormat string

const (
	// EncodingFormatFloat is the float encoding format.
	EncodingFormatFloat EmbeddingsFormat = "float"
	// EncodingFormatBase64 is the base64 encoding format.
	EncodingFormatBase64 EmbeddingsFormat = "base64"
)

// EmbeddingObject is the object type for the embedding response.
// It's value is always "embedding".
// string
type EmbeddingObject string

const (
	// EmbeddingObjectEmbedding is the embedding object type.
	EmbeddingObjectEmbedding EmbeddingObject = "embedding"
)

// CreateEmbeddingResponseObject is the object type for the create embedding response.
// It's value is always "list".
// string
type CreateEmbeddingResponseObject string

const (
	// CreateEmbeddingResponseObjectList is the list object type.
	CreateEmbeddingResponseObjectList CreateEmbeddingResponseObject = "list"
)

// EmbeddingResponse represents the response structure for embedding API.
type EmbeddingResponse struct {
	Object string `json:"object"`
	Data   []struct {
		Object    string    `json:"object"`
		Index     int       `json:"index"`
		Embedding []float64 `json:"embedding"`
	} `json:"data"`
	Model string `json:"model"`
	Usage struct {
		PromptTokens int `json:"prompt_tokens"`
		TotalTokens  int `json:"total_tokens"`
	} `json:"usage"`
	Header http.Header `json:"-"`
}

// SetHeader sets the header of the embedding response.
func (r EmbeddingResponse) SetHeader(header http.Header) { r.Header = header }

// Voice is the voice for the speech response.
//
// string
type Voice string

const (
	// TODO: add more voices/fix the ones that are missing/nonexistent

	// VoiceAlexa is the voice for Alexa.
	VoiceAlexa Voice = "alexa"
	// VoiceAmanda is the voice for Amanda.
	VoiceAmanda Voice = "amanda"
	// VoiceBrian is the voice for Brian.
	VoiceBrian Voice = "brian"
	// VoiceCarl is the voice for Carl.
	VoiceCarl Voice = "carl"
	// VoiceDavid is the voice for David.
	VoiceDavid Voice = "david"
)

// AudioFormat is the a format for audio.
// string
type AudioFormat string

const (
	// AudioFormatMP3 is the mp3 format.
	AudioFormatMP3 AudioFormat = "mp3"
	// AudioFormatOpus is the opus format.
	AudioFormatOpus AudioFormat = "opus"
	// AudioFormatAAC is the aac format.
	AudioFormatAAC AudioFormat = "aac"
	// AudioFormatFLAC is the flac format.
	AudioFormatFLAC AudioFormat = "flac"
	// AudioFormatWAV is the wav format.
	AudioFormatWAV AudioFormat = "wav"
	// AudioFormatPCM is the pcm format.
	AudioFormatPCM AudioFormat = "pcm"
)
